![[Pasted image 20250509150408.png]]
**题目一:**

> 考虑使用一个字节（8位）来表示有符号整数（例如，补码表示，其范围为 -128 到 127，或者题目中暗示的范围 -127 到 127）。
> 
> 1. 将十进制数 `85` 和 `122` 分别转换为二进制数。
> 2. 计算这两个二进制数的和。
> 3. 判断其十进制和 `85 + 122` 是否超出了该8位有符号整数的表示范围，即是否发生溢出。

**题目二:**

> 1. 将十进制数 `63.25` 转换为二进制数。
> 2. 请将转换后的二进制数规格化，并按照以下浮点数格式表示：
>     - 符号位：1位
>     - 阶码：5位 (请说明使用的偏移量或表示方法，例如图二中似乎使用了 127 作为偏移量基准，计算得到 5+127=132 作为存储的阶码)
>     - 尾数：16位 (请说明尾数部分是否包含隐含的整数位1)

![[Pasted image 20250509150035.png]]
![[Pasted image 20250509150046.png]]
![[Pasted image 20250509150101.png]]
![[Pasted image 20250509150342.png]]

![[ab5329e3d99653f9935f8f315169494d.jpg]]
*命中 (Hit)：** CPU要的数据在Cache中找到了。*   
**缺失 (Miss) / 未命中：** CPU要的数据不在Cache中，需要去下一级存储（如主存）中查找。
*   **命中率 (Hit Rate, H)：** 命中次数 / 总访问次数。
*   **缺失率 (Miss Rate, M)：** 缺失次数 / 总访问次数。显然 $M = 1 - H$。
*   **命中时间 (Hit Time, $T_{hit}$ )：** 访问Cache并取到数据所需的时间。
*   **缺失代价 (Miss Penalty, $T_{miss\_penalty}$ )：** 从下一级存储中调入数据块到Cache并送给CPU所需的时间。
*   **平均访存时间 (Average Memory Access Time, AMAT)：**    $AMAT = T_{hit} + M \times T_{miss\_penalty}$
*   **CPU时间 (CPU Time)：**    $CPU_{time} = (\text{CPU执行周期数} + \text{存储器停顿周期数}) \times \text{时钟周期时间}$    其中，存储器停顿周期数 = 访存次数 $\times$ 缺失率 $\times$ 缺失代价 (以周期为单位)
*   **CPI (Cycles Per Instruction, 每指令周期数)：**    $CPI_{actual} = CPI_{ideal} + \text{平均每条指令的存储器停顿周期数}$    
* 平均每条指令的存储器停顿周期数 = 指令平均访存次数 $\times$ 缺失率 $\times$ 缺失代价 (周期)
* **老师举的CPI计算例子 (非常重要，很可能考！)：
* **假设：
*   CPU 基准时钟频率 = 4 GHz $\implies$ 时钟周期 $T_{cycle} = 1 / (4 \times 10^9 \text{ Hz}) = 0.25 \text{ ns/cycle}$
*   理想CPI (假设所有访存都命中Cache) = 1.0
*   主存访问时间 (即L1的缺失代价，如果只有L1 Cache) = 100 ns    
*   换算成时钟周期：$100 \text{ ns} / 0.25 \text{ ns/cycle} = 400 \text{ cycles}$
*   指令的缺失率 (Instruction Miss Rate for L1) = 2% (0.02)    (这里假设每条指令平均有1次访存，即访存主要来自取指令)**情况1：只有一级缓存 (L1 Cache)**$CPI_{L1\_only} = CPI_{ideal} + (\text{指令缺失率} \times \text{L1缺失代价})$$CPI_{L1\_only} = 1.0 + (0.02 \times 400 \text{ cycles})$$CPI_{L1\_only} = 1.0 + 8 \text{ cycles}$$CPI_{L1\_only} = 9 \text{ cycles/instruction}$
* 老师说：“每一条指令平均需要九个周期，这是非常慢的一种速度。”
* 
* 
* **情况2：加入二级缓存 (L2 Cache)**
* 新增假设：
*   L2 Cache 访问时间 (从CPU发出请求，L1缺失，到L2命中并返回数据给CPU的时间) = 5 ns    *   换算成时钟周期：$5 \text{ ns} / 0.25 \text{ ns/cycle} = 20 \text{ cycles}$ (这是L1访问L2的缺失代价，或者说L2的命中时间)*   L2 的**全局缺失率 (Global Miss Rate)** = 0.5% (0.005)    *   全局缺失率是指：CPU发出的访存请求中，L1和L2都缺失的概率。*   另一种说法是 L2 的**局部缺失率 (Local Miss Rate)**。如果给出的是局部缺失率，比如 $M_{L2\_local}$，则全局缺失率 $M_{L2\_global} = M_{L1} \times M_{L2\_local}$。老师这里给的是全局缺失率，更直接。*   如果L1和L2都缺失，则最终的缺失代价仍然是访问主存的 400 个周期。$CPI_{L1+L2} = CPI_{ideal} + (\text{L1指令缺失、L2命中时的额外周期}) + (\text{L1指令缺失、L2也缺失时的额外周期})$$CPI_{L1+L2} = CPI_{ideal} + (\text{L1缺失率} \times \text{L2命中时间}) + (\text{L2全局缺失率} \times \text{主存访问时间})$注意老师的讲解方式：*   L1缺失的概率是 2%。*   在这2%的L1缺失中，有一部分会在L2命中，有一部分L2也会缺失。    *   L2全局缺失率是0.5%，这意味着原始请求中有0.5%会一直穿透到主存。    *   那么L1缺失、L2命中的概率是：L1缺失率 - L2全局缺失率 = $0.02 - 0.005 = 0.015$ (1.5%)    所以，老师的计算思路是：$CPI_{L1+L2} = CPI_{ideal} + (\text{Prob(L1 miss, L2 hit)} \times \text{L2 Hit Penalty from L1}) + (\text{Prob(L1 miss, L2 miss)} \times \text{Main Memory Penalty})$$CPI_{L1+L2} = 1.0 + ( (0.02 - 0.005) \times 20 ) + ( 0.005 \times 400 )$$CPI_{L1+L2} = 1.0 + (0.015 \times 20) + (0.005 \times 400)$$CPI_{L1+L2} = 1.0 + 0.3 + 2.0$$CPI_{L1+L2} = 3.3 \text{ cycles/instruction}$ (老师口误算成了3.4，但按数字是3.3)老师说：“当你有二级缓存之后，你就只需要3.4个周期（应为3.3）。我们再比较跟刚才那个（9周期），是不是性能提升很多？”**结论：** 加入L2 Cache后，CPI从9显著降低到3.3，性能大幅提升。
* **优化Cache性能的考虑因素：**
* 老师提到，设计系统时，需要通过仿真来测量最优的关联度 (associativity)。关联度越高，通常缺失率越低，但硬件成本和命中时间可能会增加。到一定程度后，再增加关联度带来的收益会递减。---





![[b7eb090819b8706dcf73d1e5930338d7.jpg]]
![[448333be83ea09429518bb523e4e9d8a.jpg]]

![[08559418ac09e6113a85260c0b00eae4.jpg]]

![[cdac4f20d1be5a56bc54c104b728f51b.jpg]]
![[cd6f1e4e7dd191a29342cedd404cd087.jpg]]
